<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/AchievementTracker.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/AchievementTracker.cs" />
              <option name="originalContent" value="using System;&#10;using System.Collections.Generic;&#10;// using YourRegistrarLibrary; // Uncomment and adjust as needed&#10;&#10;public class AchievementTracker&#10;{&#10;    private readonly Dictionary&lt;string, Action&gt; achievementBindings = new();&#10;&#10;    // Example: Bind an achievement to a registry value&#10;    public void BindAchievement(string registryKey, Action onAchieved)&#10;    {&#10;        achievementBindings[registryKey] = onAchieved;&#10;        // RegistrarLibrary.Bind(registryKey, () =&gt; TriggerAchievement(registryKey));&#10;        // Replace above with actual registrar binding logic&#10;    }&#10;&#10;    // Call this when a registry value changes&#10;    public void TriggerAchievement(string registryKey)&#10;    {&#10;        if (achievementBindings.TryGetValue(registryKey, out var action))&#10;        {&#10;            action?.Invoke();&#10;        }&#10;    }&#10;&#10;    // ...other tracking logic...&#10;}&#10;" />
              <option name="updatedContent" value="using System;&#10;using System.Collections.Generic;&#10;// using YourRegistrarLibrary; // Uncomment and adjust as needed&#10;&#10;public class AchievementTracker&#10;{&#10;    private readonly Dictionary&lt;string, Action&gt; achievementBindings = new();&#10;&#10;    // Example: Bind an achievement to a registry value&#10;    public void BindAchievement(string registryKey, Action onAchieved)&#10;    {&#10;        achievementBindings[registryKey] = onAchieved;&#10;        // RegistrarLibrary.Bind(registryKey, () =&gt; TriggerAchievement(registryKey));&#10;        // Replace above with actual registrar binding logic&#10;    }&#10;&#10;    // Call this when a registry value changes&#10;    public void TriggerAchievement(string registryKey)&#10;    {&#10;        if (achievementBindings.TryGetValue(registryKey, out var action))&#10;        {&#10;            action?.Invoke();&#10;        }&#10;    }&#10;&#10;    // ...other tracking logic...&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Achievements/Achievement.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Achievements/Achievement.cs" />
              <option name="originalContent" value="namespace Achievements;&#10;&#10;public class Achievement&#10;{&#10;    public string Name { get; }&#10;    public string Description { get; }&#10;    public ICriterionEvaluator Root { get; }&#10;    &#10;    public Achievement(string name, string description, ICriterionEvaluator root)&#10;    {&#10;        Name = name;&#10;        Description = description;&#10;        Root = root;&#10;    }&#10;    &#10;    public virtual bool IsUnlocked() =&gt; Root.Evaluate();&#10;&#10;    public override string ToString() =&gt; $&quot;{Name} - {Description}&quot;;&#10;}&#10;&#10;// Internal wrapper to adapt a bare condition to a criterion so it can plug into RawCriterionEvaluator&#10;internal sealed class ConditionWrapperCriterion&lt;TCondition, TContext&gt; : ICriterion&lt;TContext&gt;&#10;    where TCondition : ICondition&lt;TContext&gt;&#10;{&#10;    private readonly TCondition _condition;&#10;    public ConditionWrapperCriterion(TCondition condition) =&gt; _condition = condition;&#10;    public bool IsMet(TContext context) =&gt; _condition.RequirementsMet(context);&#10;}&#10;&#10;public sealed class AchievementBuilder&#10;{&#10;    private readonly string _name;&#10;    private readonly string _description;&#10;    private readonly CompositeEvaluator _root;&#10;    private readonly Stack&lt;CompositeEvaluator&gt; _stack = new();&#10;&#10;    private CompositeEvaluator Current =&gt; _stack.Count &gt; 0 ? _stack.Peek() : _root;&#10;&#10;    private AchievementBuilder(string name, string description)&#10;    {&#10;        _name = name;&#10;        _description = description;&#10;        _root = new CompositeEvaluator(&quot;root&quot;, EvaluationMode.All);&#10;    }&#10;&#10;    public static AchievementBuilder CreateNew(string name, string description) =&gt; new(name, description);&#10;&#10;    // Existing self-referential criterion helper (condition &amp; context are the same type)&#10;    public AchievementBuilder Add&lt;TC&gt;(string label, AbstractCriterion&lt;TC&gt; criterion, Func&lt;TC&gt; context)&#10;        where TC : CriterionCondition&lt;TC&gt;&#10;    {&#10;        Current.With(new SingleEvaluator&lt;TC&gt;(label, criterion, context));&#10;        return this;&#10;    }&#10;&#10;    // New flexible overload supporting distinct condition and runtime context types.&#10;    // Use when your requirement (stored condition) type differs from the transient runtime context type.&#10;    public AchievementBuilder AddCustom&lt;TCondition, TContext&gt;(string label, AbstractCriterion&lt;TCondition, TContext&gt; criterion, Func&lt;TContext&gt; context)&#10;        where TCondition : ICondition&lt;TContext&gt;&#10;    {&#10;        Current.With(new SingleEvaluator&lt;TCondition, TContext&gt;(label, criterion, context));&#10;        return this;&#10;    }&#10;&#10;    public AchievementBuilder AllOf(string label, Action&lt;AchievementBuilder&gt; scope)&#10;    {&#10;        var group = new CompositeEvaluator(label, EvaluationMode.All);&#10;        Current.With(group);&#10;        _stack.Push(group);&#10;        scope(this);&#10;        _stack.Pop();&#10;        return this;&#10;    }&#10;&#10;    public AchievementBuilder AnyOf(string label, Action&lt;AchievementBuilder&gt; scope)&#10;    {&#10;        var group = new CompositeEvaluator(label, EvaluationMode.Any);&#10;        Current.With(group);&#10;        _stack.Push(group);&#10;        scope(this);&#10;        _stack.Pop();&#10;        return this;&#10;    }&#10;&#10;    public AchievementBuilder AddRaw&lt;TContext&gt;(string label, ICriterion&lt;TContext&gt; criterion, Func&lt;TContext&gt; context)&#10;    {&#10;        Current.With(new RawCriterionEvaluator&lt;TContext&gt;(label, criterion, context));&#10;        return this;&#10;    }&#10;&#10;    public AchievementBuilder AddPredicate&lt;TContext&gt;(string label, Func&lt;TContext, bool&gt; predicate, Func&lt;TContext&gt; context)&#10;    {&#10;        Current.With(new RawCriterionEvaluator&lt;TContext&gt;(label, new LambdaCriterion&lt;TContext&gt;(predicate), context));&#10;        return this;&#10;    }&#10;&#10;    public AchievementBuilder AddCondition&lt;TCondition, TContext&gt;(string label, TCondition condition, Func&lt;TContext&gt; context)&#10;        where TCondition : ICondition&lt;TContext&gt;&#10;    {&#10;        Current.With(new RawCriterionEvaluator&lt;TContext&gt;(label, new ConditionWrapperCriterion&lt;TCondition, TContext&gt;(condition), context));&#10;        return this;&#10;    }&#10;&#10;    public AchievementBuilder AddUpdatable(string label, IUpdatableCriterion criterion)&#10;    {&#10;        Current.With(new UpdatableEvaluator(label, criterion));&#10;        return this;&#10;    }&#10;&#10;    public Achievement Build()&#10;    {&#10;        return new Achievement(_name, _description, _root);&#10;    }&#10;}" />
              <option name="updatedContent" value="namespace Achievements;&#10;&#10;public class Achievement&#10;{&#10;    public string Name { get; }&#10;    public string Description { get; }&#10;    public ICriterionEvaluator Root { get; }&#10;    &#10;    public Achievement(string name, string description, ICriterionEvaluator root)&#10;    {&#10;        Name = name;&#10;        Description = description;&#10;        Root = root;&#10;    }&#10;    &#10;    public virtual bool IsUnlocked() =&gt; Root.Evaluate();&#10;&#10;    public override string ToString() =&gt; $&quot;{Name} - {Description}&quot;;&#10;}&#10;&#10;// Internal wrapper to adapt a bare condition to a criterion so it can plug into RawCriterionEvaluator&#10;internal sealed class ConditionWrapperCriterion&lt;TCondition, TContext&gt; : ICriterion&lt;TContext&gt;&#10;    where TCondition : ICondition&lt;TContext&gt;&#10;{&#10;    private readonly TCondition _condition;&#10;    public ConditionWrapperCriterion(TCondition condition) =&gt; _condition = condition;&#10;    public bool IsMet(TContext context) =&gt; _condition.RequirementsMet(context);&#10;}&#10;&#10;public sealed class AchievementBuilder&#10;{&#10;    private readonly string _name;&#10;    private readonly string _description;&#10;    private readonly CompositeEvaluator _root;&#10;    private readonly Stack&lt;CompositeEvaluator&gt; _stack = new();&#10;&#10;    private CompositeEvaluator Current =&gt; _stack.Count &gt; 0 ? _stack.Peek() : _root;&#10;&#10;    private AchievementBuilder(string name, string description)&#10;    {&#10;        _name = name;&#10;        _description = description;&#10;        _root = new CompositeEvaluator(&quot;root&quot;, EvaluationMode.All);&#10;    }&#10;&#10;    public static AchievementBuilder CreateNew(string name, string description) =&gt; new(name, description);&#10;&#10;    // Existing self-referential criterion helper (condition &amp; context are the same type)&#10;    public AchievementBuilder Add&lt;TC&gt;(string label, AbstractCriterion&lt;TC&gt; criterion, Func&lt;TC&gt; context)&#10;        where TC : CriterionCondition&lt;TC&gt;&#10;    {&#10;        Current.With(new SingleEvaluator&lt;TC&gt;(label, criterion, context));&#10;        return this;&#10;    }&#10;&#10;    // New flexible overload supporting distinct condition and runtime context types.&#10;    // Use when your requirement (stored condition) type differs from the transient runtime context type.&#10;    public AchievementBuilder AddCustom&lt;TCondition, TContext&gt;(string label, AbstractCriterion&lt;TCondition, TContext&gt; criterion, Func&lt;TContext&gt; context)&#10;        where TCondition : ICondition&lt;TContext&gt;&#10;    {&#10;        Current.With(new SingleEvaluator&lt;TCondition, TContext&gt;(label, criterion, context));&#10;        return this;&#10;    }&#10;&#10;    public AchievementBuilder AllOf(string label, Action&lt;AchievementBuilder&gt; scope)&#10;    {&#10;        var group = new CompositeEvaluator(label, EvaluationMode.All);&#10;        Current.With(group);&#10;        _stack.Push(group);&#10;        scope(this);&#10;        _stack.Pop();&#10;        return this;&#10;    }&#10;&#10;    public AchievementBuilder AnyOf(string label, Action&lt;AchievementBuilder&gt; scope)&#10;    {&#10;        var group = new CompositeEvaluator(label, EvaluationMode.Any);&#10;        Current.With(group);&#10;        _stack.Push(group);&#10;        scope(this);&#10;        _stack.Pop();&#10;        return this;&#10;    }&#10;&#10;    public AchievementBuilder AddRaw&lt;TContext&gt;(string label, ICriterion&lt;TContext&gt; criterion, Func&lt;TContext&gt; context)&#10;    {&#10;        Current.With(new RawCriterionEvaluator&lt;TContext&gt;(label, criterion, context));&#10;        return this;&#10;    }&#10;&#10;    public AchievementBuilder AddPredicate&lt;TContext&gt;(string label, Func&lt;TContext, bool&gt; predicate, Func&lt;TContext&gt; context)&#10;    {&#10;        Current.With(new RawCriterionEvaluator&lt;TContext&gt;(label, new LambdaCriterion&lt;TContext&gt;(predicate), context));&#10;        return this;&#10;    }&#10;&#10;    public AchievementBuilder AddCondition&lt;TCondition, TContext&gt;(string label, TCondition condition, Func&lt;TContext&gt; context)&#10;        where TCondition : ICondition&lt;TContext&gt;&#10;    {&#10;        Current.With(new RawCriterionEvaluator&lt;TContext&gt;(label, new ConditionWrapperCriterion&lt;TCondition, TContext&gt;(condition), context));&#10;        return this;&#10;    }&#10;&#10;    public AchievementBuilder AddUpdatable(string label, IUpdatableCriterion criterion)&#10;    {&#10;        Current.With(new UpdatableEvaluator(label, criterion));&#10;        return this;&#10;    }&#10;&#10;    public Achievement Build()&#10;    {&#10;        return new Achievement(_name, _description, _root);&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Achievements/CriterionSkeleton.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Achievements/CriterionSkeleton.cs" />
              <option name="originalContent" value="namespace Achievements;&#10;&#10;// Marker interface for non-generic storage/registration&#10;public interface ICriterion { }&#10;&#10;// Generic criterion interface allowing runtime context injection&#10;public interface ICriterion&lt;in TContext&gt; : ICriterion&#10;{&#10;    bool IsMet(TContext context);&#10;}&#10;&#10;// Condition (requirement) interface – compares a runtime context against stored requirement data&#10;public interface ICondition&lt;in TContext&gt;&#10;{&#10;    bool RequirementsMet(TContext contextToCompare);&#10;}&#10;&#10;// Base class for a criterion that owns a requirement (condition) and evaluates a runtime context&#10;public abstract class AbstractCriterion&lt;TCondition, TContext&gt; : ICriterion&lt;TContext&gt;&#10;    where TCondition : ICondition&lt;TContext&gt;&#10;{&#10;    protected abstract TCondition Condition { get; }&#10;    public virtual bool IsMet(TContext context) =&gt; Condition.RequirementsMet(context);&#10;}&#10;&#10;// Convenience base type for the common case where the requirement type and the runtime context type are the same.&#10;public abstract class AbstractCriterion&lt;TContext&gt; : AbstractCriterion&lt;CriterionCondition&lt;TContext&gt;, TContext&gt;&#10;    where TContext : CriterionCondition&lt;TContext&gt;&#10;{&#10;    // In this self-referential scenario the derived class will still implement the Condition property.&#10;}&#10;&#10;// Backwards-compatible style condition base (acts as the requirement object)&#10;public abstract class CriterionCondition&lt;TContext&gt; : ICondition&lt;TContext&gt;&#10;{&#10;    public abstract bool RequirementsMet(TContext contextToCompare);&#10;}&#10;&#10;public sealed class LambdaCriterion&lt;TContext&gt; : ICriterion&lt;TContext&gt;&#10;{&#10;    private readonly Func&lt;TContext, bool&gt; _predicate;&#10;    public LambdaCriterion(Func&lt;TContext, bool&gt; predicate) =&gt; _predicate = predicate;&#10;    public bool IsMet(TContext context) =&gt; _predicate(context);&#10;}" />
              <option name="updatedContent" value="namespace Achievements;&#10;&#10;// Marker interface for non-generic storage/registration&#10;public interface ICriterion { }&#10;&#10;// Generic criterion interface allowing runtime context injection&#10;public interface ICriterion&lt;in TContext&gt; : ICriterion&#10;{&#10;    bool IsMet(TContext context);&#10;}&#10;&#10;// Condition (requirement) interface – compares a runtime context against stored requirement data&#10;public interface ICondition&lt;in TContext&gt;&#10;{&#10;    bool RequirementsMet(TContext contextToCompare);&#10;}&#10;&#10;// Base class for a criterion that owns a requirement (condition) and evaluates a runtime context&#10;public abstract class AbstractCriterion&lt;TCondition, TContext&gt; : ICriterion&lt;TContext&gt;&#10;    where TCondition : ICondition&lt;TContext&gt;&#10;{&#10;    protected abstract TCondition Condition { get; }&#10;    public virtual bool IsMet(TContext context) =&gt; Condition.RequirementsMet(context);&#10;}&#10;&#10;// Convenience base type for the common case where the requirement type and the runtime context type are the same.&#10;public abstract class AbstractCriterion&lt;TContext&gt; : AbstractCriterion&lt;CriterionCondition&lt;TContext&gt;, TContext&gt;&#10;    where TContext : CriterionCondition&lt;TContext&gt;&#10;{&#10;    // In this self-referential scenario the derived class will still implement the Condition property.&#10;}&#10;&#10;// Backwards-compatible style condition base (acts as the requirement object)&#10;public abstract class CriterionCondition&lt;TContext&gt; : ICondition&lt;TContext&gt;&#10;{&#10;    public abstract bool RequirementsMet(TContext contextToCompare);&#10;}&#10;&#10;public sealed class LambdaCriterion&lt;TContext&gt; : ICriterion&lt;TContext&gt;&#10;{&#10;    private readonly Func&lt;TContext, bool&gt; _predicate;&#10;    public LambdaCriterion(Func&lt;TContext, bool&gt; predicate) =&gt; _predicate = predicate;&#10;    public bool IsMet(TContext context) =&gt; _predicate(context);&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Achievements/Evaluators.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Achievements/Evaluators.cs" />
              <option name="originalContent" value="namespace Achievements;&#10;&#10;public enum EvaluationMode { All, Any }&#10;&#10;public interface ICriterionEvaluator&#10;{&#10;    string Label { get; }&#10;    bool Evaluate();&#10;}&#10;&#10;// New flexible evaluator supporting distinct requirement/condition and runtime context types&#10;public sealed class SingleEvaluator&lt;TCondition, TContext&gt; : ICriterionEvaluator&#10;    where TCondition : ICondition&lt;TContext&gt;&#10;{&#10;    private readonly AbstractCriterion&lt;TCondition, TContext&gt; _criterion;&#10;    private readonly Func&lt;TContext&gt; _contextProvider;&#10;    public string Label { get; }&#10;&#10;    public SingleEvaluator(string label, AbstractCriterion&lt;TCondition, TContext&gt; criterion, Func&lt;TContext&gt; contextProvider)&#10;    {&#10;        Label = label;&#10;        _criterion = criterion;&#10;        _contextProvider = contextProvider;&#10;    }&#10;&#10;    public bool Evaluate() =&gt; _criterion.IsMet(_contextProvider());&#10;}&#10;&#10;// Backwards compatible evaluator for the common self-referential pattern&#10;public sealed class SingleEvaluator&lt;TC&gt; : ICriterionEvaluator where TC : CriterionCondition&lt;TC&gt;&#10;{&#10;    private readonly SingleEvaluator&lt;CriterionCondition&lt;TC&gt;, TC&gt; _inner;&#10;    public string Label =&gt; _inner.Label;&#10;&#10;    public SingleEvaluator(string label, AbstractCriterion&lt;TC&gt; criterion, Func&lt;TC&gt; contextProvider)&#10;    {&#10;        _inner = new SingleEvaluator&lt;CriterionCondition&lt;TC&gt;, TC&gt;(label, criterion, contextProvider);&#10;    }&#10;&#10;    public bool Evaluate() =&gt; _inner.Evaluate();&#10;}&#10;&#10;// New: wrap any ICriterion&lt;TContext&gt; directly (stateful or stateless) without needing AbstractCriterion&#10;public sealed class RawCriterionEvaluator&lt;TContext&gt; : ICriterionEvaluator&#10;{&#10;    private readonly ICriterion&lt;TContext&gt; _criterion;&#10;    private readonly Func&lt;TContext&gt; _contextProvider;&#10;    public string Label { get; }&#10;&#10;    public RawCriterionEvaluator(string label, ICriterion&lt;TContext&gt; criterion, Func&lt;TContext&gt; contextProvider)&#10;    {&#10;        Label = label;&#10;        _criterion = criterion;&#10;        _contextProvider = contextProvider;&#10;    }&#10;&#10;    public bool Evaluate() =&gt; _criterion.IsMet(_contextProvider());&#10;}&#10;&#10;public sealed class UpdatableEvaluator : ICriterionEvaluator&#10;{&#10;    private readonly IUpdatableCriterion _criterion;&#10;    public string Label { get; }&#10;    public UpdatableEvaluator(string label, IUpdatableCriterion criterion)&#10;    {&#10;        Label = label;&#10;        _criterion = criterion;&#10;    }&#10;    public bool Evaluate() =&gt; _criterion.IsSatisfied;&#10;}&#10;&#10;public sealed class CompositeEvaluator : ICriterionEvaluator&#10;{&#10;    private readonly List&lt;ICriterionEvaluator&gt; _children = [];&#10;    private readonly EvaluationMode _mode;&#10;    public string Label { get; }&#10;&#10;    public CompositeEvaluator(string label, EvaluationMode mode)&#10;    {&#10;        Label = label;&#10;        _mode = mode;&#10;    }&#10;&#10;    public CompositeEvaluator With(ICriterionEvaluator evaluator)&#10;    {&#10;        _children.Add(evaluator);&#10;        return this;&#10;    }&#10;&#10;    public bool Evaluate()&#10;    {&#10;        if (_children.Count == 0) return _mode == EvaluationMode.All;&#10;        return _mode == EvaluationMode.All&#10;            ? _children.All(c =&gt; c.Evaluate())&#10;            : _children.Any(c =&gt; c.Evaluate());&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="namespace Achievements;&#10;&#10;public enum EvaluationMode { All, Any }&#10;&#10;public interface ICriterionEvaluator&#10;{&#10;    string Label { get; }&#10;    bool Evaluate();&#10;}&#10;&#10;// New flexible evaluator supporting distinct requirement/condition and runtime context types&#10;public sealed class SingleEvaluator&lt;TCondition, TContext&gt; : ICriterionEvaluator&#10;    where TCondition : ICondition&lt;TContext&gt;&#10;{&#10;    private readonly AbstractCriterion&lt;TCondition, TContext&gt; _criterion;&#10;    private readonly Func&lt;TContext&gt; _contextProvider;&#10;    public string Label { get; }&#10;&#10;    public SingleEvaluator(string label, AbstractCriterion&lt;TCondition, TContext&gt; criterion, Func&lt;TContext&gt; contextProvider)&#10;    {&#10;        Label = label;&#10;        _criterion = criterion;&#10;        _contextProvider = contextProvider;&#10;    }&#10;&#10;    public bool Evaluate() =&gt; _criterion.IsMet(_contextProvider());&#10;}&#10;&#10;// Backwards compatible evaluator for the common self-referential pattern&#10;public sealed class SingleEvaluator&lt;TC&gt; : ICriterionEvaluator where TC : CriterionCondition&lt;TC&gt;&#10;{&#10;    private readonly SingleEvaluator&lt;CriterionCondition&lt;TC&gt;, TC&gt; _inner;&#10;    public string Label =&gt; _inner.Label;&#10;&#10;    public SingleEvaluator(string label, AbstractCriterion&lt;TC&gt; criterion, Func&lt;TC&gt; contextProvider)&#10;    {&#10;        _inner = new SingleEvaluator&lt;CriterionCondition&lt;TC&gt;, TC&gt;(label, criterion, contextProvider);&#10;    }&#10;&#10;    public bool Evaluate() =&gt; _inner.Evaluate();&#10;}&#10;&#10;// New: wrap any ICriterion&lt;TContext&gt; directly (stateful or stateless) without needing AbstractCriterion&#10;public sealed class RawCriterionEvaluator&lt;TContext&gt; : ICriterionEvaluator&#10;{&#10;    private readonly ICriterion&lt;TContext&gt; _criterion;&#10;    private readonly Func&lt;TContext&gt; _contextProvider;&#10;    public string Label { get; }&#10;&#10;    public RawCriterionEvaluator(string label, ICriterion&lt;TContext&gt; criterion, Func&lt;TContext&gt; contextProvider)&#10;    {&#10;        Label = label;&#10;        _criterion = criterion;&#10;        _contextProvider = contextProvider;&#10;    }&#10;&#10;    public bool Evaluate() =&gt; _criterion.IsMet(_contextProvider());&#10;}&#10;&#10;public sealed class UpdatableEvaluator : ICriterionEvaluator&#10;{&#10;    private readonly IUpdatableCriterion _criterion;&#10;    public string Label { get; }&#10;    public UpdatableEvaluator(string label, IUpdatableCriterion criterion)&#10;    {&#10;        Label = label;&#10;        _criterion = criterion;&#10;    }&#10;    public bool Evaluate() =&gt; _criterion.IsSatisfied;&#10;}&#10;&#10;public sealed class CompositeEvaluator : ICriterionEvaluator&#10;{&#10;    private readonly List&lt;ICriterionEvaluator&gt; _children = [];&#10;    private readonly EvaluationMode _mode;&#10;    public string Label { get; }&#10;&#10;    public CompositeEvaluator(string label, EvaluationMode mode)&#10;    {&#10;        Label = label;&#10;        _mode = mode;&#10;    }&#10;&#10;    public CompositeEvaluator With(ICriterionEvaluator evaluator)&#10;    {&#10;        _children.Add(evaluator);&#10;        return this;&#10;    }&#10;&#10;    public bool Evaluate()&#10;    {&#10;        if (_children.Count == 0) return _mode == EvaluationMode.All;&#10;        return _mode == EvaluationMode.All&#10;            ? _children.All(c =&gt; c.Evaluate())&#10;            : _children.Any(c =&gt; c.Evaluate());&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Achievements/UpdatableCriteria.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Achievements/UpdatableCriteria.cs" />
              <option name="originalContent" value="namespace Achievements;&#10;&#10;/// &lt;summary&gt;&#10;/// Non-generic base for any criterion that keeps internal progress/state and exposes a satisfied flag.&#10;/// External code pushes context into such criteria via Evaluate(context) on the generic form.&#10;/// Achievements composed with these criteria only need to read IsSatisfied (no context providers required).&#10;/// &lt;/summary&gt;&#10;public interface IUpdatableCriterion&#10;{&#10;    string Name { get; }&#10;    bool IsSatisfied { get; }&#10;}&#10;&#10;/// &lt;summary&gt;&#10;/// Generic updatable criterion that receives runtime context externally and updates internal progress.&#10;/// &lt;/summary&gt;&#10;public interface IUpdatableCriterion&lt;in TContext&gt; : IUpdatableCriterion&#10;{&#10;    void Evaluate(TContext context);&#10;}&#10;&#10;/// &lt;summary&gt;&#10;/// Base class for push / event driven criteria where requirements are encapsulated in a condition object.&#10;/// &lt;/summary&gt;&#10;public abstract class UpdatableCriterion&lt;TCondition, TContext&gt; : IUpdatableCriterion&lt;TContext&gt;&#10;    where TCondition : class&#10;{&#10;    public string Name { get; }&#10;    protected TCondition Condition { get; }&#10;    public bool IsSatisfied { get; protected set; }&#10;&#10;    protected UpdatableCriterion(string name, TCondition condition)&#10;    {&#10;        Name = name;&#10;        Condition = condition;&#10;    }&#10;&#10;    public abstract void Evaluate(TContext context);&#10;}&#10;&#10;// -------------------- Example Concrete Push-Based Criteria --------------------&#10;&#10;public sealed class KillTypeCountCondition&#10;{&#10;    public string EnemyType { get; init; } = string.Empty;&#10;    public int RequiredCount { get; init; }&#10;}&#10;&#10;public sealed class KillTypeCountCriterion : UpdatableCriterion&lt;KillTypeCountCondition, string&gt;&#10;{&#10;    private int _count;&#10;    private KillTypeCountCriterion(string name, KillTypeCountCondition condition) : base(name, condition) { }&#10;&#10;    public static KillTypeCountCriterion Create(string name, string enemyType, int required) =&gt;&#10;        new(name, new KillTypeCountCondition { EnemyType = enemyType, RequiredCount = required });&#10;&#10;    public override void Evaluate(string enemyType)&#10;    {&#10;        if (IsSatisfied) return; // already done&#10;        if (enemyType == Condition.EnemyType)&#10;        {&#10;            _count++;&#10;            if (_count &gt;= Condition.RequiredCount) IsSatisfied = true;&#10;        }&#10;    }&#10;}&#10;&#10;public sealed class ScoreAccumulationCondition&#10;{&#10;    public int RequiredScore { get; init; }&#10;}&#10;&#10;public sealed class ScoreAccumulationCriterion : UpdatableCriterion&lt;ScoreAccumulationCondition, int&gt;&#10;{&#10;    private int _score;&#10;    private ScoreAccumulationCriterion(string name, ScoreAccumulationCondition condition) : base(name, condition) { }&#10;&#10;    public static ScoreAccumulationCriterion Create(string name, int requiredScore) =&gt;&#10;        new(name, new ScoreAccumulationCondition { RequiredScore = requiredScore });&#10;&#10;    public override void Evaluate(int deltaScore)&#10;    {&#10;        if (IsSatisfied) return;&#10;        _score += deltaScore;&#10;        if (_score &gt;= Condition.RequiredScore) IsSatisfied = true;&#10;    }&#10;}&#10;&#10;public sealed class DeathCountCondition&#10;{&#10;    public int RequiredDeaths { get; init; }&#10;}&#10;&#10;public sealed class DeathCountCriterion : UpdatableCriterion&lt;DeathCountCondition, int&gt;&#10;{&#10;    private int _deaths;&#10;    private DeathCountCriterion(string name, DeathCountCondition condition) : base(name, condition) { }&#10;&#10;    public static DeathCountCriterion Create(string name, int requiredDeaths) =&gt;&#10;        new(name, new DeathCountCondition { RequiredDeaths = requiredDeaths });&#10;&#10;    public override void Evaluate(int deathIncrement)&#10;    {&#10;        if (IsSatisfied) return;&#10;        _deaths += deathIncrement;&#10;        if (_deaths &gt;= Condition.RequiredDeaths) IsSatisfied = true;&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="namespace Achievements;&#10;&#10;/// &lt;summary&gt;&#10;/// Non-generic base for any criterion that keeps internal progress/state and exposes a satisfied flag.&#10;/// External code pushes context into such criteria via Evaluate(context) on the generic form.&#10;/// Achievements composed with these criteria only need to read IsSatisfied (no context providers required).&#10;/// &lt;/summary&gt;&#10;public interface IUpdatableCriterion&#10;{&#10;    string Name { get; }&#10;    bool IsSatisfied { get; }&#10;}&#10;&#10;/// &lt;summary&gt;&#10;/// Generic updatable criterion that receives runtime context externally and updates internal progress.&#10;/// &lt;/summary&gt;&#10;public interface IUpdatableCriterion&lt;in TContext&gt; : IUpdatableCriterion&#10;{&#10;    void Evaluate(TContext context);&#10;}&#10;&#10;/// &lt;summary&gt;&#10;/// Base class for push / event driven criteria where requirements are encapsulated in a condition object.&#10;/// &lt;/summary&gt;&#10;public abstract class UpdatableCriterion&lt;TCondition, TContext&gt; : IUpdatableCriterion&lt;TContext&gt;&#10;    where TCondition : class&#10;{&#10;    public string Name { get; }&#10;    protected TCondition Condition { get; }&#10;    public bool IsSatisfied { get; protected set; }&#10;&#10;    protected UpdatableCriterion(string name, TCondition condition)&#10;    {&#10;        Name = name;&#10;        Condition = condition;&#10;    }&#10;&#10;    public abstract void Evaluate(TContext context);&#10;}&#10;&#10;// -------------------- Example Concrete Push-Based Criteria --------------------&#10;&#10;public sealed class KillTypeCountCondition&#10;{&#10;    public string EnemyType { get; init; } = string.Empty;&#10;    public int RequiredCount { get; init; }&#10;}&#10;&#10;public sealed class KillTypeCountCriterion : UpdatableCriterion&lt;KillTypeCountCondition, string&gt;&#10;{&#10;    private int _count;&#10;    private KillTypeCountCriterion(string name, KillTypeCountCondition condition) : base(name, condition) { }&#10;&#10;    public static KillTypeCountCriterion Create(string name, string enemyType, int required) =&gt;&#10;        new(name, new KillTypeCountCondition { EnemyType = enemyType, RequiredCount = required });&#10;&#10;    public override void Evaluate(string enemyType)&#10;    {&#10;        if (IsSatisfied) return; // already done&#10;        if (enemyType == Condition.EnemyType)&#10;        {&#10;            _count++;&#10;            if (_count &gt;= Condition.RequiredCount) IsSatisfied = true;&#10;        }&#10;    }&#10;}&#10;&#10;public sealed class ScoreAccumulationCondition&#10;{&#10;    public int RequiredScore { get; init; }&#10;}&#10;&#10;public sealed class ScoreAccumulationCriterion : UpdatableCriterion&lt;ScoreAccumulationCondition, int&gt;&#10;{&#10;    private int _score;&#10;    private ScoreAccumulationCriterion(string name, ScoreAccumulationCondition condition) : base(name, condition) { }&#10;&#10;    public static ScoreAccumulationCriterion Create(string name, int requiredScore) =&gt;&#10;        new(name, new ScoreAccumulationCondition { RequiredScore = requiredScore });&#10;&#10;    public override void Evaluate(int deltaScore)&#10;    {&#10;        if (IsSatisfied) return;&#10;        _score += deltaScore;&#10;        if (_score &gt;= Condition.RequiredScore) IsSatisfied = true;&#10;    }&#10;}&#10;&#10;public sealed class DeathCountCondition&#10;{&#10;    public int RequiredDeaths { get; init; }&#10;}&#10;&#10;public sealed class DeathCountCriterion : UpdatableCriterion&lt;DeathCountCondition, int&gt;&#10;{&#10;    private int _deaths;&#10;    private DeathCountCriterion(string name, DeathCountCondition condition) : base(name, condition) { }&#10;&#10;    public static DeathCountCriterion Create(string name, int requiredDeaths) =&gt;&#10;        new(name, new DeathCountCondition { RequiredDeaths = requiredDeaths });&#10;&#10;    public override void Evaluate(int deathIncrement)&#10;    {&#10;        if (IsSatisfied) return;&#10;        _deaths += deathIncrement;&#10;        if (_deaths &gt;= Condition.RequiredDeaths) IsSatisfied = true;&#10;    }&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>