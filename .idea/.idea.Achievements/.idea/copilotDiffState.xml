<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/AchievementTracker.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/AchievementTracker.cs" />
              <option name="originalContent" value="using System;&#10;using System.Collections.Generic;&#10;// using YourRegistrarLibrary; // Uncomment and adjust as needed&#10;&#10;public class AchievementTracker&#10;{&#10;    private readonly Dictionary&lt;string, Action&gt; achievementBindings = new();&#10;&#10;    // Example: Bind an achievement to a registry value&#10;    public void BindAchievement(string registryKey, Action onAchieved)&#10;    {&#10;        achievementBindings[registryKey] = onAchieved;&#10;        // RegistrarLibrary.Bind(registryKey, () =&gt; TriggerAchievement(registryKey));&#10;        // Replace above with actual registrar binding logic&#10;    }&#10;&#10;    // Call this when a registry value changes&#10;    public void TriggerAchievement(string registryKey)&#10;    {&#10;        if (achievementBindings.TryGetValue(registryKey, out var action))&#10;        {&#10;            action?.Invoke();&#10;        }&#10;    }&#10;&#10;    // ...other tracking logic...&#10;}&#10;" />
              <option name="updatedContent" value="using System;&#10;using System.Collections.Generic;&#10;// using YourRegistrarLibrary; // Uncomment and adjust as needed&#10;&#10;public class AchievementTracker&#10;{&#10;    private readonly Dictionary&lt;string, Action&gt; achievementBindings = new();&#10;&#10;    // Example: Bind an achievement to a registry value&#10;    public void BindAchievement(string registryKey, Action onAchieved)&#10;    {&#10;        achievementBindings[registryKey] = onAchieved;&#10;        // RegistrarLibrary.Bind(registryKey, () =&gt; TriggerAchievement(registryKey));&#10;        // Replace above with actual registrar binding logic&#10;    }&#10;&#10;    // Call this when a registry value changes&#10;    public void TriggerAchievement(string registryKey)&#10;    {&#10;        if (achievementBindings.TryGetValue(registryKey, out var action))&#10;        {&#10;            action?.Invoke();&#10;        }&#10;    }&#10;&#10;    // ...other tracking logic...&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Achievements/AchievementTracker.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Achievements/AchievementTracker.cs" />
              <option name="originalContent" value="namespace Achievements;&#10;&#10;public interface IAchievementStore&#10;{&#10;    bool TryGetUnlockDate(string key, out DateTime unlockedAt);&#10;    void MarkUnlocked(string key, DateTime unlockedAt);&#10;}&#10;&#10;public sealed class InMemoryAchievementStore : IAchievementStore&#10;{&#10;    private readonly Dictionary&lt;string, DateTime&gt; _map = new();&#10;    public bool TryGetUnlockDate(string key, out DateTime unlockedAt) =&gt; _map.TryGetValue(key, out unlockedAt);&#10;    public void MarkUnlocked(string key, DateTime unlockedAt) =&gt; _map[key] = unlockedAt;&#10;}&#10;&#10;public sealed class AchievementTracker(IAchievementStore? store = null)&#10;{&#10;    private sealed record AchievementEntry(string Key, Achievement Achievement)&#10;    {&#10;        public bool WasUnlockedMutable;&#10;        public DateTime? UnlockedAtMutable;&#10;&#10;        public AchievementEntry(string key, Achievement achievement, bool wasUnlocked, DateTime? unlockedAt)&#10;            : this(key, achievement)&#10;        {&#10;            WasUnlockedMutable = wasUnlocked;&#10;            UnlockedAtMutable = unlockedAt;&#10;        }&#10;    }&#10;&#10;    private readonly IAchievementStore _store = store ?? new InMemoryAchievementStore();&#10;    private readonly Dictionary&lt;string, AchievementEntry&gt; _entries = new(StringComparer.OrdinalIgnoreCase);&#10;&#10;    public event Action&lt;Achievement, DateTime&gt; OnUnlocked = delegate { };&#10;&#10;    // Subscribe to criterion satisfaction to auto-evaluate all achievements.&#10;    static AchievementTracker()&#10;    {&#10;        // no-op static ctor ensures type initialization before any instance methods&#10;    }&#10;    public AchievementTracker() : this(null) { }&#10;&#10;    public void Register(Achievement achievement, bool evaluateImmediately = true)&#10;    {&#10;        var key = achievement.Name;&#10;        if (_entries.ContainsKey(key))&#10;            throw new InvalidOperationException($&quot;Achievement with name '{key}' already registered.&quot;);&#10;&#10;        // Subscribe on first registration to avoid unused subscriptions when no tracker entries exist.&#10;        if (_entries.Count == 0)&#10;        {&#10;            CriterionEvents.OnConditionSatisfied += OnCriterionSatisfied;&#10;        }&#10;&#10;        DateTime? unlockedAt = null;&#10;        var wasUnlocked = false;&#10;        if (_store.TryGetUnlockDate(key, out var dt))&#10;        {&#10;            wasUnlocked = true;&#10;            unlockedAt = dt;&#10;        }&#10;&#10;        var entry = new AchievementEntry(key, achievement, wasUnlocked, unlockedAt);&#10;        _entries[key] = entry;&#10;&#10;        if (evaluateImmediately)&#10;        {&#10;            Evaluate(achievement);&#10;        }&#10;    }&#10;&#10;    private void OnCriterionSatisfied(CriterionEvents.ConditionSatisfied _)&#10;    {&#10;        EvaluateAll();&#10;    }&#10;&#10;    public bool IsUnlocked(Achievement achievement) =&gt;&#10;        _entries.TryGetValue(achievement.Name,&#10;            out var e) &amp;&amp;&#10;        (e.WasUnlockedMutable || e.Achievement.IsUnlocked());&#10;&#10;    public DateTime? GetUnlockDate(Achievement achievement) =&gt; _entries.TryGetValue(achievement.Name, out var e) ? e.UnlockedAtMutable : null;&#10;&#10;    public IEnumerable&lt;(string Key, Achievement Achievement, bool IsUnlocked, DateTime? UnlockedAt)&gt; Snapshot()&#10;    {&#10;        return _entries.Values.Select(e =&gt; (e.Key, e.Achievement, e.WasUnlockedMutable, e.UnlockedAtMutable));&#10;    }&#10;&#10;    public int EvaluateAll()&#10;    {&#10;        return _entries.Values.Count(entry =&gt; Evaluate(entry.Achievement));&#10;    }&#10;&#10;    /// &lt;summary&gt;&#10;    /// Evaluates a single achievement by key, firing OnUnlocked if it transitions to unlocked.&#10;    /// Returns true if it was just unlocked, false otherwise.&#10;    /// &lt;/summary&gt;&#10;    /// &lt;param name=&quot;achievement&quot;&gt;The achievement to evaluate.&lt;/param&gt;&#10;    /// &lt;remarks&gt;It is best practice to retain a static read-only reference to the &lt;/remarks&gt;&#10;    /// &lt;returns&gt;Whether the achievement was unlocked.&lt;/returns&gt;&#10;    public bool Evaluate(Achievement achievement)&#10;    {&#10;        var key = achievement.Name;&#10;        &#10;        if (!_entries.TryGetValue(key, out var e)) return false;&#10;&#10;        if (e.WasUnlockedMutable)&#10;            return false; // already recorded as unlocked&#10;&#10;        if (!e.Achievement.IsUnlocked())&#10;            return false; // still locked&#10;&#10;        // transition to unlocked&#10;        var now = DateTime.UtcNow;&#10;        e.WasUnlockedMutable = true;&#10;        e.UnlockedAtMutable = now;&#10;        _store.MarkUnlocked(key, now);&#10;        OnUnlocked(e.Achievement, now);&#10;        return true;&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="namespace Achievements;&#10;&#10;public interface IAchievementStore&#10;{&#10;    bool TryGetUnlockDate(string key, out DateTime unlockedAt);&#10;    void MarkUnlocked(string key, DateTime unlockedAt);&#10;}&#10;&#10;public sealed class InMemoryAchievementStore : IAchievementStore&#10;{&#10;    private readonly Dictionary&lt;string, DateTime&gt; _map = new();&#10;    public bool TryGetUnlockDate(string key, out DateTime unlockedAt) =&gt; _map.TryGetValue(key, out unlockedAt);&#10;    public void MarkUnlocked(string key, DateTime unlockedAt) =&gt; _map[key] = unlockedAt;&#10;}&#10;&#10;public sealed class AchievementTracker(IAchievementStore? store = null)&#10;{&#10;    private sealed record AchievementEntry(string Key, Achievement Achievement)&#10;    {&#10;        public bool WasUnlockedMutable;&#10;        public DateTime? UnlockedAtMutable;&#10;&#10;        public AchievementEntry(string key, Achievement achievement, bool wasUnlocked, DateTime? unlockedAt)&#10;            : this(key, achievement)&#10;        {&#10;            WasUnlockedMutable = wasUnlocked;&#10;            UnlockedAtMutable = unlockedAt;&#10;        }&#10;    }&#10;&#10;    private readonly IAchievementStore _store = store ?? new InMemoryAchievementStore();&#10;    private readonly Dictionary&lt;string, AchievementEntry&gt; _entries = new(StringComparer.OrdinalIgnoreCase);&#10;&#10;    public event Action&lt;Achievement, DateTime&gt; OnUnlocked = delegate { };&#10;&#10;    // Subscribe to criterion satisfaction to auto-evaluate all achievements.&#10;    static AchievementTracker()&#10;    {&#10;        // no-op static ctor ensures type initialization before any instance methods&#10;    }&#10;    public AchievementTracker() : this(null) { }&#10;&#10;    public void Register(Achievement achievement, bool evaluateImmediately = true)&#10;    {&#10;        var key = achievement.Name;&#10;        if (_entries.ContainsKey(key))&#10;            throw new InvalidOperationException($&quot;Achievement with name '{key}' already registered.&quot;);&#10;&#10;        // Subscribe on first registration to avoid unused subscriptions when no tracker entries exist.&#10;        if (_entries.Count == 0)&#10;        {&#10;            CriterionEvents.OnConditionSatisfied += OnCriterionSatisfied;&#10;        }&#10;&#10;        DateTime? unlockedAt = null;&#10;        var wasUnlocked = false;&#10;        if (_store.TryGetUnlockDate(key, out var dt))&#10;        {&#10;            wasUnlocked = true;&#10;            unlockedAt = dt;&#10;        }&#10;&#10;        var entry = new AchievementEntry(key, achievement, wasUnlocked, unlockedAt);&#10;        _entries[key] = entry;&#10;&#10;        if (evaluateImmediately)&#10;        {&#10;            Evaluate(achievement);&#10;        }&#10;    }&#10;&#10;    private void OnCriterionSatisfied(CriterionEvents.ConditionSatisfied _)&#10;    {&#10;        EvaluateAll();&#10;    }&#10;&#10;    public bool IsUnlocked(Achievement achievement) =&gt;&#10;        _entries.TryGetValue(achievement.Name,&#10;            out var e) &amp;&amp;&#10;        (e.WasUnlockedMutable || e.Achievement.IsUnlocked());&#10;&#10;    public DateTime? GetUnlockDate(Achievement achievement) =&gt; _entries.TryGetValue(achievement.Name, out var e) ? e.UnlockedAtMutable : null;&#10;&#10;    public IEnumerable&lt;(string Key, Achievement Achievement, bool IsUnlocked, DateTime? UnlockedAt)&gt; Snapshot()&#10;    {&#10;        return _entries.Values.Select(e =&gt; (e.Key, e.Achievement, e.WasUnlockedMutable, e.UnlockedAtMutable));&#10;    }&#10;&#10;    public int EvaluateAll()&#10;    {&#10;        return _entries.Values.Count(entry =&gt; Evaluate(entry.Achievement));&#10;    }&#10;&#10;    /// &lt;summary&gt;&#10;    /// Evaluates a single achievement by key, firing OnUnlocked if it transitions to unlocked.&#10;    /// Returns true if it was just unlocked, false otherwise.&#10;    /// &lt;/summary&gt;&#10;    /// &lt;param name=&quot;achievement&quot;&gt;The achievement to evaluate.&lt;/param&gt;&#10;    /// &lt;remarks&gt;It is best practice to retain a static read-only reference to the &lt;/remarks&gt;&#10;    /// &lt;returns&gt;Whether the achievement was unlocked.&lt;/returns&gt;&#10;    public bool Evaluate(Achievement achievement)&#10;    {&#10;        var key = achievement.Name;&#10;        &#10;        if (!_entries.TryGetValue(key, out var e)) return false;&#10;&#10;        if (e.WasUnlockedMutable)&#10;            return false; // already recorded as unlocked&#10;&#10;        if (!e.Achievement.IsUnlocked())&#10;            return false; // still locked&#10;&#10;        // transition to unlocked&#10;        var now = DateTime.UtcNow;&#10;        e.WasUnlockedMutable = true;&#10;        e.UnlockedAtMutable = now;&#10;        _store.MarkUnlocked(key, now);&#10;        OnUnlocked(e.Achievement, now);&#10;        return true;&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Achievements/UpdatableCriteria.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Achievements/UpdatableCriteria.cs" />
              <option name="originalContent" value="namespace Achievements;&#10;&#10;// Minimal per-achievement handle interface used by evaluators and produced only via&#10;// AbstractCriterion&lt;TCondition,TContext&gt;. End users do not implement this directly; they&#10;// create handles through Criteria.&lt;Root&gt;.Create(...).&#10;public interface IUpdatableCriterion&#10;{&#10;    string Name { get; }&#10;    bool IsSatisfied { get; }&#10;}&#10;" />
              <option name="updatedContent" value="namespace Achievements;&#10;&#10;// Minimal per-achievement handle interface used by evaluators and produced only via&#10;// AbstractCriterion&lt;TCondition,TContext&gt;. End users do not implement this directly; they&#10;// create handles through Criteria.&lt;Root&gt;.Create(...).&#10;public interface IUpdatableCriterion&#10;{&#10;    string Name { get; }&#10;    bool IsSatisfied { get; }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>